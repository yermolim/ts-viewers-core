// Generated by dts-bundle-generator v5.9.0

import { Mat3, Vec2 } from 'mathador';

export declare class ByteUtils {
	static parseIntFromBytes(bytes: Uint8Array): number;
	static int8ToBytes(int: number): Uint8Array;
	static int16ToBytes(int: number, le?: boolean): Uint8Array;
	static int32ToBytes(int: number, le?: boolean): Uint8Array;
	static int32ArrayToBytes(ints: number[], le?: boolean): Uint8Array;
	static bytesToInt32Array(bytes: Uint8Array, le?: boolean): Int32Array;
	static xorBytes(bytes: Uint8Array, n: number): Uint8Array;
	static arraysEqual(a: Uint8Array, b: Uint8Array): boolean;
	static findSubarrayIndex(arr: Uint8Array, sub: Uint8Array): number;
	static hexStringToBytes(hexString: string): Uint8Array;
	static getBit(n: number, bitPosition: number): 1 | 0;
	static setBit(n: number, bitPosition: number): number;
	static clearBit(n: number, bitPosition: number): number;
	static updateBit(n: number, bitPosition: number, bitValue: boolean): number;
}
export declare class DomUtils {
	static htmlToElements(html: string): HTMLElement[];
	static promisify<T>(callback: () => T): Promise<T>;
	static runEmptyTimeout(): Promise<void>;
	static downloadFile(blob: Blob, name?: string): void;
	static loadImageAsync(url: string, revoke?: boolean): Promise<HTMLImageElement>;
}
export declare type CurveData = [
	control1: Vec2,
	control2: Vec2,
	end: Vec2
];
export declare class CloudCurveData {
	start: Vec2;
	curves: CurveData[];
	static buildFromPolyline(polylinePoints: Vec2[], maxArcSize: number): CloudCurveData;
	static buildFromEllipse(rx: number, ry: number, maxArcSize: number, matrix?: Mat3): CloudCurveData;
}
export interface SmoothPathData {
	positions: Vec2[];
}
export interface SmoothPathOptions {
	bufferSize?: number;
	id?: number;
}
export declare abstract class SmoothPath {
	private static readonly _defaultBufferSize;
	protected readonly _id: number;
	get id(): number;
	protected readonly _bufferSize: number;
	get bufferSize(): number;
	protected _currentPath: SmoothPathData;
	protected _paths: SmoothPathData[];
	get paths(): SmoothPathData[];
	get pathCount(): number;
	protected _positionBuffer: Vec2[];
	protected _currentPathString: string;
	constructor(options?: SmoothPathOptions);
	endPath(): void;
	addPosition(pos: Vec2): void;
	protected appendPositionToBuffer(pos: Vec2): void;
	protected getAverageBufferPosition(offset: number): Vec2;
	protected updateCurrentPath(): string;
}
export declare type Double = readonly [
	x: number,
	y: number
];
export declare type Quadruple = readonly [
	x1: number,
	y1: number,
	x2: number,
	y2: number
];
export declare type Hextuple = readonly [
	a: number,
	b: number,
	d: number,
	e: number,
	g: number,
	h: number
];
export declare type Octuple = readonly [
	x1: number,
	y1: number,
	x2: number,
	y2: number,
	x3: number,
	y3: number,
	x4: number,
	y4: number
];
export interface SvgSmoothPathData extends SmoothPathData {
	path: SVGPathElement;
}
export interface SvgSmoothPathOptions extends SmoothPathOptions {
	bufferSize?: number;
	strokeWidth?: number;
	color?: Quadruple;
	id?: number;
}
export declare class SvgSmoothPath extends SmoothPath {
	private static readonly _defaultStrokeWidth;
	private static readonly _defaultColor;
	protected _strokeWidth: number;
	get strokeWidth(): number;
	protected _color: Quadruple;
	get color(): Quadruple;
	protected _group: SVGGraphicsElement;
	get group(): SVGGraphicsElement;
	protected _currentPath: SvgSmoothPathData;
	protected _paths: SvgSmoothPathData[];
	get paths(): SvgSmoothPathData[];
	constructor(options?: SvgSmoothPathOptions);
	newPath(startPosition: Vec2): void;
	removePath(path: SVGPathElement): void;
	removeLastPath(): void;
	protected updateCurrentPath(): string;
}
export declare class SvgTempPath {
	protected readonly _path: SVGPathElement;
	get path(): SVGGElement;
	constructor();
	set(fill: string, stroke: string, w: number, points: Vec2[], close?: boolean): void;
	insertAfter(element: Element): void;
	remove(): void;
}
export declare type ListenerLike = (this: HTMLElement, e: any) => any;
export declare class EventService {
	private _element;
	get element(): HTMLElement;
	private readonly _eventMap;
	constructor(container: HTMLElement);
	destroy(): void;
	addListener<K extends keyof HTMLElementEventMap>(key: K, listener: (this: HTMLElement, e: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
	removeListener(key: keyof HTMLElementEventMap, listener: ListenerLike): void;
	removeAllListenersForKey(key: keyof HTMLElementEventMap): void;
	removeAllListeners(): void;
	getListenersByKey(key: keyof HTMLElementEventMap): ListenerLike[];
	hasListenersForKey(key: keyof HTMLElementEventMap): boolean;
	dispatchEvent<K extends keyof HTMLElementEventMap>(e: HTMLElementEventMap[K]): void;
}
export declare class LinkedListNode<T> {
	data: T;
	next: LinkedListNode<T>;
	constructor(data: T);
}
export declare class LinkedList<T> {
	private _head;
	get head(): T;
	private _length;
	get length(): number;
	get tail(): T;
	constructor(head?: T);
	push(value: T): void;
	insert(value: T, n: number): T;
	replace(value: T, n: number): T;
	remove(n: number): T;
	clear(): void;
	get(n: number): T;
	pop(): T;
	has(value: T, comparator?: (a: T, b: T) => boolean): boolean;
	findIndex(value: T, comparator?: (a: T, b: T) => boolean): number;
	[Symbol.iterator](): Generator<T, void, unknown>;
}
export declare class UUID {
	static getRandomUuid(): string;
}

export {};
